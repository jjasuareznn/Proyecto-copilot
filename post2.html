<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Representación de Grafos - Julián Suárez | INCCA</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Navegación -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <i class="fas fa-sitemap"></i>
                <h1>Blog de Grafos</h1>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html#inicio" class="nav-link">Inicio</a></li>
                <li><a href="index.html#articulos" class="nav-link">Artículos</a></li>
                <li><a href="index.html#recursos" class="nav-link">Recursos</a></li>
                <li><a href="index.html#contacto" class="nav-link">Contacto</a></li>
            </ul>
        </div>
    </nav>

    <!-- Artículo -->
    <article class="post-container">
        <div class="post-header">
            <div class="container">
                <div class="breadcrumb">
                    <a href="index.html">Inicio</a>
                    <span>/</span>
                    <span>Representación de Grafos</span>
                </div>
                <h1 class="post-title">Representación de Grafos: Matrices y Listas de Adyacencia</h1>
                <div class="post-meta">
                    <span class="meta-autor"><i class="fas fa-user"></i> Julián Suárez | INCCA</span>
                    <span class="meta-fecha"><i class="fas fa-calendar"></i> 1 de Diciembre, 2025</span>
                    <span class="meta-lectura"><i class="fas fa-clock"></i> 10 minutos de lectura</span>
                </div>
            </div>
        </div>

        <div class="post-content">
            <div class="container">
                <!-- Tabla de contenidos -->
                <div class="toc">
                    <h3>Tabla de Contenidos</h3>
                    <ul>
                        <li><a href="#introduccion">Introducción</a></li>
                        <li><a href="#matriz">Matriz de Adyacencia</a></li>
                        <li><a href="#lista">Lista de Adyacencia</a></li>
                        <li><a href="#comparacion">Comparación</a></li>
                        <li><a href="#implementacion">Implementación Práctica</a></li>
                        <li><a href="#conclusion">Conclusión</a></li>
                    </ul>
                </div>

                <section id="introduccion">
                    <h2>Introducción</h2>
                    <p>
                        Una de las decisiones más importantes al trabajar con grafos es cómo representarlos en memoria. Existen dos enfoques principales: <strong>matrices de adyacencia</strong> y <strong>listas de adyacencia</strong>. Cada uno tiene ventajas y desventajas específicas que dependen del tipo de grafo y del algoritmo que vayamos a implementar.
                    </p>
                    <p>
                        Entender estas representaciones es crucial para escribir código eficiente y elegir la estructura de datos más apropiada para cada problema.
                    </p>
                </section>

                <section id="matriz">
                    <h2>Matriz de Adyacencia</h2>
                    <p>
                        Una <strong>matriz de adyacencia</strong> es una matriz de tamaño n×n (donde n es el número de vértices) que almacena información sobre las aristas del grafo.
                    </p>

                    <div class="info-box">
                        <h3>Definición</h3>
                        <p>
                            Una matriz de adyacencia M se define como:
                        </p>
                        <ul>
                            <li><strong>M[i][j] = 1</strong> si existe una arista entre los vértices i y j</li>
                            <li><strong>M[i][j] = 0</strong> si no existe arista entre i y j</li>
                            <li>En grafos ponderados, M[i][j] contiene el peso de la arista</li>
                        </ul>
                    </div>

                    <h3>Ejemplo Visual: Grafo No Dirigido</h3>
                    <p>
                        Considera el siguiente grafo con 4 vértices (A, B, C, D):
                    </p>

                    <div class="visual-container">
                        <svg viewBox="0 0 300 250" class="graph-svg">
                            <!-- Aristas -->
                            <line x1="80" y1="60" x2="220" y2="60" class="edge" />
                            <line x1="80" y1="60" x2="80" y2="180" class="edge" />
                            <line x1="220" y1="60" x2="150" y2="180" class="edge" />
                            <line x1="80" y1="180" x2="150" y2="180" class="edge" />

                            <!-- Nodos -->
                            <circle cx="80" cy="60" r="15" class="node" />
                            <text x="80" y="65" text-anchor="middle" class="node-label">A</text>

                            <circle cx="220" cy="60" r="15" class="node" />
                            <text x="220" y="65" text-anchor="middle" class="node-label">B</text>

                            <circle cx="80" cy="180" r="15" class="node" />
                            <text x="80" y="185" text-anchor="middle" class="node-label">C</text>

                            <circle cx="150" cy="180" r="15" class="node" />
                            <text x="150" y="185" text-anchor="middle" class="node-label">D</text>
                        </svg>
                    </div>

                    <h3>Su Matriz de Adyacencia Sería:</h3>
                    <div class="tabla-grafo">
                        <table>
                            <tr>
                                <th>  </th>
                                <th>A</th>
                                <th>B</th>
                                <th>C</th>
                                <th>D</th>
                            </tr>
                            <tr>
                                <th>A</th>
                                <td>0</td>
                                <td>1</td>
                                <td>1</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <th>B</th>
                                <td>1</td>
                                <td>0</td>
                                <td>0</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <th>C</th>
                                <td>1</td>
                                <td>0</td>
                                <td>0</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <th>D</th>
                                <td>0</td>
                                <td>1</td>
                                <td>1</td>
                                <td>0</td>
                            </tr>
                        </table>
                    </div>

                    <h3>Ventajas</h3>
                    <ul>
                        <li><strong>Consultas rápidas:</strong> Verificar si existe una arista es O(1)</li>
                        <li><strong>Fácil de implementar:</strong> Es solo una matriz 2D</li>
                        <li><strong>Buena para grafos densos:</strong> Cuando hay muchas aristas</li>
                        <li><strong>Operaciones matriciales:</strong> Se pueden usar muchos algoritmos de álgebra lineal</li>
                    </ul>

                    <h3>Desventajas</h3>
                    <ul>
                        <li><strong>Alto uso de memoria:</strong> Requiere O(n²) espacio, incluso para grafos con pocas aristas</li>
                        <li><strong>Iteración lenta:</strong> Recorrer todas las aristas toma O(n²) incluso si hay pocas</li>
                        <li><strong>Ineficiente para grafos dispersos:</strong> Mucho espacio desperdiciado</li>
                    </ul>
                </section>

                <section id="lista">
                    <h2>Lista de Adyacencia</h2>
                    <p>
                        Una <strong>lista de adyacencia</strong> es una forma alternativa de representar un grafo usando una lista para cada vértice que contiene sus vértices adyacentes.
                    </p>

                    <div class="info-box">
                        <h3>Definición</h3>
                        <p>
                            Para cada vértice v, se mantiene una lista de todos los vértices u tales que existe una arista (v, u).
                        </p>
                    </div>

                    <h3>Representación del Mismo Grafo:</h3>
                    <div class="code-block">
                        <pre><code>
A → [B, C]
B → [A, D]
C → [A, D]
D → [B, C]

O en estructura de datos:
{
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}
                        </code></pre>
                    </div>

                    <h3>Implementación en Python</h3>
                    <div class="code-block">
                        <pre><code>
class Grafo:
    def __init__(self, vertices):
        self.vertices = vertices
        self.grafo = {v: [] for v in vertices}
    
    def agregar_arista(self, u, v):
        """Agregar una arista no dirigida"""
        self.grafo[u].append(v)
        self.grafo[v].append(u)

# Uso
g = Grafo(['A', 'B', 'C', 'D'])
g.agregar_arista('A', 'B')
g.agregar_arista('A', 'C')
g.agregar_arista('B', 'D')
g.agregar_arista('C', 'D')
                        </code></pre>
                    </div>

                    <h3>Ventajas</h3>
                    <ul>
                        <li><strong>Uso eficiente de memoria:</strong> Requiere solo O(V + E) espacio</li>
                        <li><strong>Iteración eficiente:</strong> Recorrer todas las aristas es O(V + E)</li>
                        <li><strong>Óptima para grafos dispersos:</strong> No desperdicia espacio</li>
                        <li><strong>Más flexible:</strong> Se pueden almacenar pesos en la lista</li>
                    </ul>

                    <h3>Desventajas</h3>
                    <ul>
                        <li><strong>Consultas más lentas:</strong> Verificar si existe una arista es O(grado)</li>
                        <li><strong>Más compleja de implementar:</strong> Requiere más código</li>
                        <li><strong>Uso de memoria variable:</strong> Depende de la distribución de aristas</li>
                    </ul>
                </section>

                <section id="comparacion">
                    <h2>Comparación de Complejidad</h2>
                    <div class="tabla-grafo">
                        <table>
                            <tr>
                                <th>Operación</th>
                                <th>Matriz de Adyacencia</th>
                                <th>Lista de Adyacencia</th>
                            </tr>
                            <tr>
                                <td>Agregar vértice</td>
                                <td>O(n²)</td>
                                <td>O(1)</td>
                            </tr>
                            <tr>
                                <td>Agregar arista</td>
                                <td>O(1)</td>
                                <td>O(1)</td>
                            </tr>
                            <tr>
                                <td>Eliminar arista</td>
                                <td>O(1)</td>
                                <td>O(grado)</td>
                            </tr>
                            <tr>
                                <td>Consultar arista</td>
                                <td>O(1)</td>
                                <td>O(grado)</td>
                            </tr>
                            <tr>
                                <td>Encontrar todos los vecinos</td>
                                <td>O(n)</td>
                                <td>O(grado)</td>
                            </tr>
                            <tr>
                                <td>Espacio necesario</td>
                                <td>O(n²)</td>
                                <td>O(n + m)</td>
                            </tr>
                        </table>
                    </div>

                    <h3>¿Cuál Elegir?</h3>
                    <div class="caracteristicas">
                        <h4>Usa Matriz de Adyacencia cuando:</h4>
                        <ul>
                            <li>El grafo es denso (muchas aristas)</li>
                            <li>Necesitas consultas rápidas de aristas</li>
                            <li>El número de vértices es pequeño</li>
                            <li>Trabajarás con operaciones matriciales</li>
                        </ul>
                    </div>

                    <div class="info-box">
                        <h4>Usa Lista de Adyacencia cuando:</h4>
                        <ul>
                            <li>El grafo es disperso (pocas aristas)</li>
                            <li>Necesitas iterar sobre las aristas eficientemente</li>
                            <li>El número de vértices es grande</li>
                            <li>Quieres una representación compacta</li>
                        </ul>
                    </div>
                </section>

                <section id="implementacion">
                    <h2>Implementación Práctica Completa</h2>

                    <h3>Clase Grafo con Lista de Adyacencia</h3>
                    <div class="code-block">
                        <pre><code>
class GrafoListaAdyacencia:
    """Grafo usando lista de adyacencia"""
    
    def __init__(self):
        self.grafo = {}
    
    def agregar_vertice(self, v):
        """Agregar un vértice"""
        if v not in self.grafo:
            self.grafo[v] = []
    
    def agregar_arista(self, u, v, peso=1):
        """Agregar una arista ponderada"""
        self.agregar_vertice(u)
        self.agregar_vertice(v)
        self.grafo[u].append((v, peso))
        # Descomentar para grafo no dirigido:
        # self.grafo[v].append((u, peso))
    
    def obtener_vecinos(self, v):
        """Obtener vecinos de un vértice"""
        return self.grafo.get(v, [])
    
    def obtener_grado(self, v):
        """Obtener grado de un vértice"""
        return len(self.grafo.get(v, []))


# Ejemplo de uso
g = GrafoListaAdyacencia()
g.agregar_arista('A', 'B', 5)
g.agregar_arista('A', 'C', 3)
g.agregar_arista('B', 'D', 2)

print(g.obtener_vecinos('A'))  # [('B', 5), ('C', 3)]
print(g.obtener_grado('A'))     # 2
                        </code></pre>
                    </div>
                </section>

                <section id="conclusion">
                    <h2>Conclusión</h2>
                    <p>
                        La elección entre matriz de adyacencia y lista de adyacencia es una decisión importante que afecta la eficiencia de tu algoritmo. No existe una opción universalmente correcta; depende del tipo de grafo y las operaciones que necesites realizar.
                    </p>
                    <p>
                        Para la mayoría de los problemas prácticos con grafos dispersos, la lista de adyacencia es la opción preferida por su eficiencia en espacio y tiempo.
                    </p>
                </section>

                <!-- Navegación entre posts -->
                <div class="post-navigation">
                    <a href="post1.html" class="btn btn-secondary">← Anterior: Introducción a Grafos</a>
                    <a href="post3.html" class="btn btn-primary">Siguiente: Algoritmos de Recorrido →</a>
                </div>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Blog de Grafos - Julián Suárez | Universidad INCCA | Estructura de Datos 2</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem; color: rgba(255,255,255,0.8);">Todos los derechos reservados</p>
            <div class="social-links">
                <a href="#" class="social-link" title="GitHub"><i class="fab fa-github"></i></a>
                <a href="#" class="social-link" title="LinkedIn"><i class="fab fa-linkedin"></i></a>
                <a href="#" class="social-link" title="Twitter"><i class="fab fa-twitter"></i></a>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
