<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos de Recorrido BFS y DFS - Julián Suárez | INCCA</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/post.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Navegación -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <i class="fas fa-sitemap"></i>
                <h1>Blog de Grafos</h1>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html#inicio" class="nav-link">Inicio</a></li>
                <li><a href="index.html#articulos" class="nav-link">Artículos</a></li>
                <li><a href="index.html#recursos" class="nav-link">Recursos</a></li>
                <li><a href="index.html#contacto" class="nav-link">Contacto</a></li>
            </ul>
        </div>
    </nav>

    <!-- Artículo -->
    <article class="post-container">
        <div class="post-header">
            <div class="container">
                <div class="breadcrumb">
                    <a href="index.html">Inicio</a>
                    <span>/</span>
                    <span>Algoritmos de Recorrido</span>
                </div>
                <h1 class="post-title">Algoritmos de Recorrido: BFS y DFS</h1>
                <div class="post-meta">
                    <span class="meta-autor"><i class="fas fa-user"></i> Julián Suárez | INCCA</span>
                    <span class="meta-fecha"><i class="fas fa-calendar"></i> 1 de Diciembre, 2025</span>
                    <span class="meta-lectura"><i class="fas fa-clock"></i> 12 minutos de lectura</span>
                </div>
            </div>
        </div>

        <div class="post-content">
            <div class="container">
                <!-- Tabla de contenidos -->
                <div class="toc">
                    <h3>Tabla de Contenidos</h3>
                    <ul>
                        <li><a href="#introduccion">Introducción</a></li>
                        <li><a href="#bfs">Búsqueda en Amplitud (BFS)</a></li>
                        <li><a href="#dfs">Búsqueda en Profundidad (DFS)</a></li>
                        <li><a href="#comparacion">Comparación BFS vs DFS</a></li>
                        <li><a href="#aplicaciones">Aplicaciones Prácticas</a></li>
                        <li><a href="#conclusion">Conclusión</a></li>
                    </ul>
                </div>

                <section id="introduccion">
                    <h2>Introducción</h2>
                    <p>
                        Los algoritmos de recorrido son fundamentales en la teoría de grafos. Permiten visitar todos los vértices de un grafo de manera sistemática, lo cual es el punto de partida para muchos algoritmos más complejos como búsqueda de caminos, detección de ciclos, y cálculo de componentes conexas.
                    </p>
                    <p>
                        Los dos algoritmos más importantes son:
                    </p>
                    <ul>
                        <li><strong>BFS (Breadth-First Search):</strong> Búsqueda por amplitud</li>
                        <li><strong>DFS (Depth-First Search):</strong> Búsqueda por profundidad</li>
                    </ul>
                </section>

                <section id="bfs">
                    <h2>Búsqueda en Amplitud (BFS)</h2>

                    <h3>¿Qué es BFS?</h3>
                    <p>
                        BFS es un algoritmo que explora el grafo <strong>nivel por nivel</strong>. Comienza en un vértice de inicio y explora todos sus vecinos antes de pasar a los vecinos de estos vecinos.
                    </p>

                    <div class="info-box">
                        <h3>Características Clave</h3>
                        <ul>
                            <li>Utiliza una <strong>cola (queue)</strong> para almacenar vértices</li>
                            <li>Explora primero los vértices más cercanos</li>
                            <li>Completa el nivel completo antes de pasar al siguiente</li>
                            <li>Tiempo: O(V + E), Espacio: O(V)</li>
                        </ul>
                    </div>

                    <h3>Pseudocódigo de BFS</h3>
                    <div class="code-block">
                        <pre><code>
algoritmo BFS(grafo, inicio):
    cola = Nueva Cola
    visitados = Conjunto vacío
    
    cola.encolar(inicio)
    visitados.agregar(inicio)
    
    mientras cola NO esté vacía:
        vértice = cola.desencolar()
        procesar(vértice)
        
        para cada vecino en grafo.obtener_vecinos(vértice):
            si vecino NO está en visitados:
                cola.encolar(vecino)
                visitados.agregar(vecino)
                        </code></pre>
                    </div>

                    <h3>Implementación en Python</h3>
                    <div class="code-block">
                        <pre><code>
from collections import deque

def BFS(grafo, inicio):
    """
    Realiza una búsqueda en amplitud desde un vértice
    
    Args:
        grafo: Diccionario con lista de adyacencia
        inicio: Vértice de inicio
    
    Returns:
        Lista con el orden de visitación
    """
    visitados = set()
    resultado = []
    cola = deque([inicio])
    
    visitados.add(inicio)
    
    while cola:
        vértice = cola.popleft()
        resultado.append(vértice)
        
        for vecino in grafo[vértice]:
            if vecino not in visitados:
                visitados.add(vecino)
                cola.append(vecino)
    
    return resultado

# Ejemplo de uso
grafo = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

print(BFS(grafo, 'A'))  # ['A', 'B', 'C', 'D']
                        </code></pre>
                    </div>

                    <h3>Ejemplo Visual: Orden de Exploración</h3>
                    <div class="visual-container">
                        <svg viewBox="0 0 400 300" class="graph-svg">
                            <!-- Aristas -->
                            <line x1="100" y1="60" x2="250" y2="60" class="edge" />
                            <line x1="100" y1="60" x2="100" y2="180" class="edge" />
                            <line x1="250" y1="60" x2="150" y2="180" class="edge" />
                            <line x1="100" y1="180" x2="150" y2="180" class="edge" />

                            <!-- Nodos -->
                            <circle cx="100" cy="60" r="15" class="node" />
                            <text x="100" y="65" text-anchor="middle" class="node-label">A(1)</text>

                            <circle cx="250" cy="60" r="15" class="node" />
                            <text x="250" y="65" text-anchor="middle" class="node-label">B(2)</text>

                            <circle cx="100" cy="180" r="15" class="node" />
                            <text x="100" y="185" text-anchor="middle" class="node-label">C(3)</text>

                            <circle cx="150" cy="180" r="15" class="node" />
                            <text x="150" y="185" text-anchor="middle" class="node-label">D(4)</text>
                        </svg>
                    </div>

                    <p>
                        <strong>Orden de visita en BFS:</strong> A(1) → B(2) → C(3) → D(4)
                    </p>
                </section>

                <section id="dfs">
                    <h2>Búsqueda en Profundidad (DFS)</h2>

                    <h3>¿Qué es DFS?</h3>
                    <p>
                        DFS es un algoritmo que explora el grafo <strong>lo más profundo posible</strong> antes de retroceder. Sigue una rama hasta su final antes de explorar otras ramas.
                    </p>

                    <div class="caracteristicas">
                        <h3>Características Clave</h3>
                        <ul>
                            <li>Utiliza una <strong>pila (stack)</strong> o <strong>recursión</strong></li>
                            <li>Explora profundamente antes de ir a otro nivel</li>
                            <li>Puede usarse de forma iterativa o recursiva</li>
                            <li>Tiempo: O(V + E), Espacio: O(V)</li>
                        </ul>
                    </div>

                    <h3>Pseudocódigo de DFS (Recursivo)</h3>
                    <div class="code-block">
                        <pre><code>
algoritmo DFS(grafo, vértice, visitados):
    visitados.agregar(vértice)
    procesar(vértice)
    
    para cada vecino en grafo.obtener_vecinos(vértice):
        si vecino NO está en visitados:
            DFS(grafo, vecino, visitados)
                        </code></pre>
                    </div>

                    <h3>Implementación en Python (Recursiva)</h3>
                    <div class="code-block">
                        <pre><code>
def DFS_recursivo(grafo, vértice, visitados=None):
    """DFS usando recursión"""
    if visitados is None:
        visitados = set()
    
    visitados.add(vértice)
    resultado = [vértice]
    
    for vecino in grafo[vértice]:
        if vecino not in visitados:
            resultado.extend(
                DFS_recursivo(grafo, vecino, visitados)
            )
    
    return resultado

# Uso
grafo = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

print(DFS_recursivo(grafo, 'A'))  # ['A', 'B', 'D', 'C']
                        </code></pre>
                    </div>

                    <h3>Implementación en Python (Iterativa)</h3>
                    <div class="code-block">
                        <pre><code>
def DFS_iterativo(grafo, inicio):
    """DFS usando una pila"""
    visitados = set()
    resultado = []
    pila = [inicio]
    
    while pila:
        vértice = pila.pop()
        
        if vértice not in visitados:
            visitados.add(vértice)
            resultado.append(vértice)
            
            # Agregar vecinos a la pila
            for vecino in reversed(grafo[vértice]):
                if vecino not in visitados:
                    pila.append(vecino)
    
    return resultado
                        </code></pre>
                    </div>

                    <h3>Ejemplo Visual: Orden de Exploración</h3>
                    <div class="visual-container">
                        <svg viewBox="0 0 400 300" class="graph-svg">
                            <!-- Aristas -->
                            <line x1="100" y1="60" x2="250" y2="60" class="edge" />
                            <line x1="100" y1="60" x2="100" y2="180" class="edge" />
                            <line x1="250" y1="60" x2="150" y2="180" class="edge" />
                            <line x1="100" y1="180" x2="150" y2="180" class="edge" />

                            <!-- Nodos -->
                            <circle cx="100" cy="60" r="15" class="node" />
                            <text x="100" y="65" text-anchor="middle" class="node-label">A(1)</text>

                            <circle cx="250" cy="60" r="15" class="node" />
                            <text x="250" y="65" text-anchor="middle" class="node-label">B(3)</text>

                            <circle cx="100" cy="180" r="15" class="node" />
                            <text x="100" y="185" text-anchor="middle" class="node-label">C(4)</text>

                            <circle cx="150" cy="180" r="15" class="node" />
                            <text x="150" y="185" text-anchor="middle" class="node-label">D(2)</text>
                        </svg>
                    </div>

                    <p>
                        <strong>Orden de visita en DFS:</strong> A(1) → B(3) → D(2) → C(4)
                    </p>
                </section>

                <section id="comparacion">
                    <h2>Comparación: BFS vs DFS</h2>

                    <div class="tabla-grafo">
                        <table>
                            <tr>
                                <th>Característica</th>
                                <th>BFS</th>
                                <th>DFS</th>
                            </tr>
                            <tr>
                                <td>Estructura de Datos</td>
                                <td>Cola (Queue)</td>
                                <td>Pila (Stack)</td>
                            </tr>
                            <tr>
                                <td>Complejidad Temporal</td>
                                <td>O(V + E)</td>
                                <td>O(V + E)</td>
                            </tr>
                            <tr>
                                <td>Complejidad Espacial</td>
                                <td>O(V)</td>
                                <td>O(V)</td>
                            </tr>
                            <tr>
                                <td>Orden de Exploración</td>
                                <td>Por niveles</td>
                                <td>Por profundidad</td>
                            </tr>
                            <tr>
                                <td>Recursión</td>
                                <td>No es natural</td>
                                <td>Muy natural</td>
                            </tr>
                            <tr>
                                <td>Árbol de Spanning</td>
                                <td>Más ancho</td>
                                <td>Más profundo</td>
                            </tr>
                            <tr>
                                <td>Camino más Corto</td>
                                <td>Sí, garantizado</td>
                                <td>No garantizado</td>
                            </tr>
                        </table>
                    </div>

                    <h3>¿Cuál Elegir?</h3>
                    <div class="info-box">
                        <h4>Usa BFS cuando:</h4>
                        <ul>
                            <li>Necesitas el camino más corto (en grafos sin pesos)</li>
                            <li>Buscas el nivel/distancia de cada vértice</li>
                            <li>Necesitas explorar por niveles</li>
                            <li>Trabajas con grafos bipartitos</li>
                        </ul>
                    </div>

                    <div class="caracteristicas">
                        <h4>Usa DFS cuando:</h4>
                        <ul>
                            <li>Necesitas detectar ciclos</li>
                            <li>Buscas componentes conexas fuertemente conectadas</li>
                            <li>Requieres ordenamiento topológico</li>
                            <li>Resuelves problemas de backtracking</li>
                        </ul>
                    </div>
                </section>

                <section id="aplicaciones">
                    <h2>Aplicaciones Prácticas</h2>

                    <h3>Aplicaciones de BFS</h3>
                    <ul>
                        <li><strong>Redes Sociales:</strong> Encontrar conexiones a distancia N de un usuario</li>
                        <li><strong>Mapas/GPS:</strong> Encontrar la ruta más corta</li>
                        <li><strong>Prueba de Bipartitez:</strong> Determinar si un grafo es bipartito</li>
                        <li><strong>Análisis de redes:</strong> Encontrar el diámetro de una red</li>
                    </ul>

                    <h3>Aplicaciones de DFS</h3>
                    <ul>
                        <li><strong>Detección de ciclos:</strong> Saber si existe un ciclo en el grafo</li>
                        <li><strong>Ordenamiento topológico:</strong> Ordenar tareas con dependencias</li>
                        <li><strong>Componentes fuertemente conectadas:</strong> Encontrar subgrupos en redes</li>
                        <li><strong>Puzzles y Laberintos:</strong> Encontrar salida usando backtracking</li>
                        <li><strong>Análisis de Compiladores:</strong> Análisis de dependencias</li>
                    </ul>
                </section>

                <section id="conclusion">
                    <h2>Conclusión</h2>
                    <p>
                        BFS y DFS son dos algoritmos fundamentales que forman la base de muchos algoritmos más avanzados. Cada uno tiene su propósito:
                    </p>
                    <ul>
                        <li><strong>BFS</strong> es ideal para encontrar caminos cortos y explorar por niveles</li>
                        <li><strong>DFS</strong> es ideal para detectar ciclos y ordenamiento topológico</li>
                    </ul>
                    <p>
                        Dominar estos algoritmos te permitirá resolver una amplia variedad de problemas de grafos eficientemente.
                    </p>
                </section>

                <!-- Navegación entre posts -->
                <div class="post-navigation">
                    <a href="post2.html" class="btn btn-secondary">← Anterior: Representación de Grafos</a>
                    <a href="index.html" class="btn btn-primary">Volver al Inicio →</a>
                </div>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Blog de Grafos - Julián Suárez | Universidad INCCA | Estructura de Datos 2</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem; color: rgba(255,255,255,0.8);">Todos los derechos reservados</p>
            <div class="social-links">
                <a href="#" class="social-link" title="GitHub"><i class="fab fa-github"></i></a>
                <a href="#" class="social-link" title="LinkedIn"><i class="fab fa-linkedin"></i></a>
                <a href="#" class="social-link" title="Twitter"><i class="fab fa-twitter"></i></a>
            </div>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
